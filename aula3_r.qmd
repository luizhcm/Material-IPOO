---
title: Conceitos Básicos de Orientação a Objetos:<br>Definição de Classes, Métodos, Construtores e Destrutores<br><br>
title-slide-attributes:
    data-background-size: contain
    data-background-position-x: center
    data-background-position-y: center
---

## Conteúdo desta Aula  

::::{.columns style='display: flex !important; height: 70%; align-items: center;'}

::: {.column width="30%"}
![](figuras/professor1-1.png){fig-alt="Professor1-1" fig-align="center"}
:::

::: {.column width="70%"}
::: {.nonincremental}
::: {style="font-size: 120%;"}
- XXX
:::
:::
:::

::::

## Definição de uma Classe
::: {.fontsize90}
O código-fonte de uma classe pode ser dividido em duas partes principais:

- Parte externa: simplesmente nomeia a classe.
- Parte interna: contém todo o código que define a classe.
:::

. . .

::: {.fontsize90}
A parte externa se apresenta da seguinte maneira:
```{.java code-line-numbers="false"}
public class NomeDaClasse{
    //Parte interna omitida
}
```
:::

. . .

::: {.fontsize90}
Essa parte externa é semelhante para diferentes classes:

- As palavras `public` e `class` são palavras reservadas da linguagem Java.
- `NomeDaClasse` é escolhido por quem criou a classe.
    - Por convenção, começamos os nomes das classes com letra maiúscula.
:::

## Definição de uma Classe
::: {.fontsize80}
A parte interna das classes é onde definimos:

- Atributos: armazenam os dados para o uso de cada objeto.
- Construtores: permitem que cada objeto seja configurado adequadamente quando ele é criado. 
- Métodos: implementam o comportamento dos objetos.
:::

. . .

::: {.fontsize80}
A parte interna se apresenta da seguinte maneira:
```{.java code-line-numbers="false"}
public class NomeDaClasse{
    //Atributos
    //Construtores
    //Métodos
}
```
A linguagem Java permite que o programador escolha a ordem da implementação dos atributos, construtores e métodos dentro da classe.

- Usualmente coloca-se primeiro os atributos, depois os construtores e, por fim, os métodos.
:::


## Utilizando um Exemplo

::::{.columns style='display: flex !important; align-items: top;'}

::: {.column width="25%"}
![](figuras/maquina_bilhetes.png){fig-alt="Mensagens" fig-align="left" width=80%}
:::

::: {.column width="75%"}
Vamos utilizar como exemplo um projeto que contém somente uma classe, a [MaquinaBilhetes]{.alert}.

- Essa classe modela uma máquina de vender bilhetes simples que emite bilhetes com preço fixo.
- O preço do bilhete é definido por meio do construtor.
- Essa máquina considera que os clientes irão inserir a quantidade correta de dinheiro antes de tentar emitir um bilhete.
:::

::::

## A Máquina de Bilhetes
::::{.columns style='display: flex !important; align-items: center;'}

::: {.column width="25%"}
![](figuras/maquina_bilhetes.png){fig-alt="Mensagens" fig-align="left" width=80%}
:::

::: {.column width="75%"}
::: {.fontsize90}
Funcionamento básico dessa máquina de bilhetes:

- Clientes inserem dinheiro na máquina e, depois, solicitam que um bilhete seja impresso.
- O cliente pode inserir dinheiro na máquina várias vezes para atingir o preço do bilhete que deseja comprar.
- A máquina mantém a soma total do dinheiro inserido pelo cliente em cada operação de compra.
- A máquina também armazena a quantidade total de dinheiro que ela coletou nas operações de compra.
- Apesar de a máquina lidar apenas com bilhete de preço único, posso criar múltiplas instâncias dessa classe com diferentes configurações de preço.
:::
:::

::::


## Analisando a Classe: Atributos 

```{.java code-line-numbers="false"}
public class MaquinaBilhetes{
    // Preço de um bilhete dessa máquina.
    private int preco;
    // Quantidade de dinheiro inserido pelo usuário.
    private int saldo;
    // Quantidade total de dinheiro coletado pela máquina.
    private int total;

    //Construtor e métodos omitidos
}
```

::::{.columns style='display: flex !important; align-items: center;'}

::: {.column width="70%"}
::: {.fontsize70}
Nessa classe temos três atributos: preço, saldo e total.

**Para que servem os atributos?**

 - Eles são espaços dentro de um objeto que podem ser usados para armazenar valores.
    - Cada objeto criado terá um espaço para cada atributo declarado em sua classe.
:::
:::

::: {.column width="30%"}
::: {.fragment}
![](figuras/objeto_ticket_machine.png){fig-alt="Mensagens" fig-align="left" width=80%}
:::
:::

::::


## Analisando a Classe: Atributos 
:::{.callout-note title="Conceito" icon=false}
Os atributos armazenam dados para um objeto utilizar. Eles também são conhecidos como [variáveis de instância]{.alert}.
:::

. . .

::::{.columns style='display: flex !important; align-items: center;'}

::: {.column width="60%"}
::: {.fontsize80}
A definição desses três atributos indica que:

- Eles são atributos **privados** ([private]{.alert}) do objeto.
- Todos são do tipo [int]{.alert}, o que significa que cada um pode armazenar um único valor inteiro.
:::
:::

::: {.column width="40%"}
```{.java code-line-numbers="false"}
public class MaquinaBilhetes{
    private int preco;
    private int saldo;
    private int total;

    //Construtor e métodos omitidos
}
```
:::
::::

. . .

::: {.fontsize80}
Veja que os [atributos]{.alert} são conhecidos como [variáveis]{.alert}, ou seja, eles podem [variar ao longo do tempo]{.alert}.

- Por exemplo, na **máquina de bilhetes**, à medida em que mais dinheiro é inserido na máquina, o **valor** armazenado no atributo **saldo** é **alterado**.
:::


## Construtores

:::{.callout-note title="Conceito" icon=false}
Os [construtores]{.alert} permitem colocar cada [objeto]{.alert} em um [estado previamente definido]{.alert} para ser utilizado. Ou seja, o construtor [inicializa um objeto]{.alert} para um estado adequado no [momento da sua criação]{.alert}.
:::

. . .

::::{.columns style='display: flex !important; align-items: top;'}

::: {.column width="25%"}
![](figuras/construtor.png){fig-alt="Mensagens" fig-align="left" width=80%}
:::

::: {.column width="75%"}
::: {.fontsize80}
O construtor é um método especial que:

- **Sempre** tem o **mesmo nome da classe** onde ele está definido.
- **Não tem tipo de retorno**, pois ele retorna implicitamente a referência para o objeto.
- Assim como qualquer método, ele **pode ter parâmetros**.
:::
:::
::::


## Analisando a Classe: Construtores
::::{.columns style='display: flex !important; align-items: center;'}

::: {.column width="50%"}
::: {.fontsize70}
No [corpo]{.alert} (tudo que está entre `{` e `}`) desse construtor [três atributos]{.alert} do objeto estão sendo [inicializados]{.alert}.

- *saldo* e *total* são [inicializados com constantes]{.alert} (neste caso, com zero).
- *preco* está sendo inicializado por um [valor passado por parâmetro]{.alert} para o construtor.
    - ou seja, ele é [inicializado]{.alert} por valor determinado [fora da classe]{.alert} *MaquinaBilhetes*.
:::
:::

::: {.column width="50%"}
```{.java code-line-numbers="false"}
public class MaquinaBilhetes{
    //Atributos omitidos
    
    public MaquinaBilhetes(int custoBilhete){
        preco = custoBilhete;
        saldo = 0;
        total = 0;
    }
    
    //Métodos omitidos
}
```
:::
::::

. . .

:::: {.columns style='display: flex !important; align-items: top;'}

::: {.column width="15%"}
![](figuras/jovem.png){fig-alt="Pensando" fig-align="center" width=60%}
:::

::: {.column width="85%"}
::: {.fontsize70}
**Mas porque o preço do bilhete é recebido de fora?**

- A ideia é que possamos criar várias máquinas (objetos) a partir da classe *MaquinaBilhetes*.
    - E que cada máquina possa operar com bilhetes de preços diferentes.
    - Por isso, não temos como saber o preço do bilhete de uma máquina específica antes de ela ser criada.
:::
:::
::::


## Analisando a Classe: Construtores
::: {.fontsize90}
Em Java, todos os atributos são automaticamente inicializados com um valor padrão se não forem explicitamente inicializados.

- Para atributos dos tipos *int*, *float* e *double* o valor padrão é zero.
:::

. . .

:::: {.columns style='display: flex !important; align-items: top;'}

::: {.column width="15%"}
![](figuras/pessoa_com_problema1.png){fig-alt="Pensando" fig-align="center" width=100%}
:::

::: {.column width="85%"}
::: {.fontsize90}
**Mas então porque os atributos *preco* e *total* foram inicializados no construtor da classe *MaquinaBilhetes*?**

- Porque assim documentamos que realmente queremos que esses atributos tenham valor inicial igual a zero.
    - Ninguém pensará que esquecemos de inicializar esses atributos.
- O leitor dessa classe não deixará de entender o código se ele não souber o valor padrão do Java para esses atributos.
:::
:::
::::


## Passando Dados via Parâmetros
:::{.fontsize80}
Os [construtores]{.alert} e [métodos]{.alert} podem [receber valores]{.alert} via seus [parâmetros]{.alert}.

- Os [parâmetros]{.alert} são [variáveis]{.alert} definidas na assinatura do construtor ou de um método.
:::



:::: {.columns style='display: flex !important; align-items: center;' .fragment}

::: {.column width="20%"}
**Exemplo:**
:::

::: {.column width="80%" }
```{.java code-line-numbers="false"}
public MaquinaBilhetes(int custoBilhete)
```
:::
::::

:::{.fontsize80}
- Veja nesse exemplo da classe *MaquinaBilhetes* que o **construtor** tem somente **um parâmetro** (*custoBilhete*) do tipo *int*.
    - Do **mesmo tipo do atributo** *preco* que armazenará o valor desse parâmetro.

- Vale observar que, diferentemente de um atributo, um [parâmetro]{.alert} é usado para [guardar uma informação temporária]{.alert}.
    - Parâmetros são usados para trazer dados de fora do objeto para dentro do seu construtor ou método.
:::


## Passando Dados via Parâmetros
:::{.fontsize75}
O nome do [parâmetro declarado na assinatura]{.alert} de um construtor ou método é denominado [parâmetro formal.]{.alert}

- É comum chamá-lo apenas de parâmetro.
:::
. . .

:::{.fontsize75}
**Exemplo:**
A classe *MaquinaBilhetes* apresenta a seguinte assinatura para seu construtor:
:::
```{.java code-line-numbers="false"}
public MaquinaBilhetes(int custoBilhete)
```
:::{.fontsize75}
- Neste caso, `custoBilhete` é o **parâmetro formal**.
:::
. . .

:::{.fontsize75}
Já o [valor do parâmetro]{.alert} passado de fora do objeto é chamados de [parâmetro real]{.alert} ou [argumento]{.alert}.
:::

. . .

:::{.fontsize75}
**Exemplo:** 
Para instanciar uma máquina de bilhetes para emitir bilhetes que custam 50 centavos,  precisamos chamar o construtor da classe *MaquinaBilhetes* da seguinte maneira:
:::
```{.java code-line-numbers="false"}
maquina1 = new MaquinaBilhetes(50)
``` 
:::{.fontsize75}

- Neste caso, o valor `50` é o **parâmetro real** ou **argumento**.
:::

## Passando Dados via Parâmetros

:::{.callout-note title="Conceito" icon=false}
O escopo de uma variável define a seção de código-fonte de onde ela pode ser acessada.
:::


::::{.columns style='display: flex !important; height: 70%; align-items: top;' .fragment}

::: {.column width="70%"}
:::{.nonincremental}
- O **escopo** de um [parâmetro]{.alert} formal está restrito ao [corpo do construtor ou método]{.alert} onde ele foi declarado. 
:::
- De modo diferente, o **escopo** de um [atributo]{.alert} é o total da definição da classe, ou seja, ele pode ser acessado de [qualquer lugar dentro da classe]{.alert}.
:::

::: {.column width="30%"}
![](figuras/escopo_variavel.png){fig-alt="Escopo_variavel" fig-align="center" width=100%}
:::

::::


## Passando Dados via Parâmetros

:::{.callout-note title="Conceito" icon=false}
O tempo de vida de uma variável define quanto tempo uma variável continuará existindo antes de ser destruída.
:::


::::{.columns style='display: flex !important; height: 70%; align-items: top;' .fragment .fontsize90}

::: {.column width="75%"}
:::{.nonincremental}
- O **tempo de vida** de um [parâmetro]{.alert} formal está limitado a uma [única chamada de um construtor ou método]{.alert}.
    - Ou seja, [ao finalizar a execução]{.alert} do construtor ou método, os seus [parâmetros]{.alert} formais [desaparecem]{.alert} e os [valores]{.alert} que eles armazenam são [perdidos]{.alert}. 
:::
- De modo diferente, o **tempo de vida** de um [atributo]{.alert} é o [mesmo do objeto]{.alert} a que ele pertence.
:::

::: {.column width="25%"}
![](figuras/tempo.png){fig-alt="Escopo_variavel" fig-align="center" width=80%}
:::

::::


## Analisando a Classe: Métodos de Acesso
:::{.callout-note title="Conceito" icon=false .fontsize90}
**Métodos de acesso** retornam **informações** ao chamador sobre o **estado de um objeto**, ou seja, eles fornecem acesso ao estado do objeto. O método `obterPreco` é um exemplo de método de acesso.
:::
::::{.columns style='display: flex !important; align-items: center;'}

::: {.column width="65%"}
::: {.fontsize70}
Todo [método]{.alert} tem [duas partes]{.alert}: a [assinatura]{.alert} e o [corpo]{.alert} do método.

- No caso do método *obterPreco*, a **assinatura** é `public int obterPreco()` e o **corpo do método** é tudo que fica entre `{` `}`, que pode conter declarações e instruções.
    - No corpo desse método há apenas uma instrução de retorno (`return preco`).
    - Essa instrução é responsável por **retornar um valor inteiro** para **corresponder ao tipo** de retorno **declarado na assinatura** do método.

:::
:::

::: {.column width="35%"}
```{.java code-line-numbers="false"}
public class MaquinaBilhetes{
    //Atributos omitidos
    //Construtor omitido

    public int obterPreco(){
        return preco;
    }
    
    //Demais métodos omitidos
}
```
:::
::::

. . .

:::{.callout-warning title="Atenção" icon=false .fontsize90}
Quando um método contém uma **instrução de retorno** (`return`), ela é sempre a **instrução final** desse método. Ou seja, nenhuma instrução colocada após a instrução de retorno será executada. 
:::


